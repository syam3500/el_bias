F1 = F1,
f_beta = f_beta
))
metrics_df <- data.frame(
Method = "RRFlow",
F1 = dist_f1,
F5 = dist_f5,
Percent_FN = dist_fnr,
Percent_FP = dist_fpr
)
all_distributions <- rbind(all_distributions, metrics_df)
## RSD is calculated only for RRFs between 0.05 and 1
## 'Compounds with RRF lower than 0.05 are excluded from UF calculation (20 times lower than the internal standard).page 8
## Therefore, as a criterion for RRF selection, only compounds with an RRF less than 1 are actually considered for UF calculation. page 8
rsd <- function(x) {
x_use = x[x<=1&x>0.05]
return(sd(x_use, na.rm = TRUE) / mean(x_use, na.rm = TRUE))
}
## Simulation starts
set.seed(123)
N_sim <- 10000
N_extractables <- 80
total_FN <- 0
total_FP <- 0
total_TP <- 0
total_TN <- 0
# remove 0 values
RRF_GCMS_superior0 <- gcms_clap_clean$"5 µg/mL"
RRF_GCMS_superior0 <- RRF_GCMS_superior0[RRF_GCMS_superior0 > 0]
# Apply Part 18 formula for database
UF <- 1/(1-rsd(RRF_GCMS_superior0))
# Start simulation
for (i in 1:N_sim) {
## 1) Concentration around the AET
base_conc_sim <- runif(N_extractables, min = 0.5 * AET, max = 2 * AET)
## A) Sampling from the GC/MS dataset (5µg/mL)
simulated_RRF <- sample(gcms_clap_clean$"5 µg/mL", size = N_extractables, replace = FALSE)
## IV) RRflow condition
## add a normal / lognormal distribution to get a "exp" RRF with some variability e.g 30%
exp_RRF <- simulated_RRF * rnorm(n = N_extractables, 1, 0.3)
exp_conc <- base_conc_sim * simulated_RRF   # experimental concentration : True concentration with the actual RRF
corrected_conc <- exp_conc * UF             # corrected concentration: Exp * UF (conservative method)
condition <- (simulated_RRF < 1)  # Condition only for LOW responders
corrected_conc[condition] <- exp_conc[condition] / exp_RRF[condition] # average value of the RRF RRFlow application in extractables amount rescaling ( The average RRF determined by the RRFlow will be used to re-calculate the amount of the corresponding compound detected in the extractables study , will assume that it is in the linearity range)
is_above_threshold <- base_conc_sim > AET
reported_above_threshold <- corrected_conc > AET
## Count per iteration
iter_TP <- sum(is_above_threshold & reported_above_threshold, na.rm = TRUE)
iter_FP <- sum(!is_above_threshold & reported_above_threshold, na.rm = TRUE)
iter_FN <- sum(is_above_threshold & !reported_above_threshold, na.rm = TRUE)
iter_TN <- sum(!is_above_threshold & !reported_above_threshold, na.rm = TRUE)
total_TP <- total_TP + iter_TP
total_FP <- total_FP + iter_FP
total_FN <- total_FN + iter_FN
total_TN <- total_TN + iter_TN
# metrics per iterations
iter_prec <- if((iter_TP + iter_FP) > 0) iter_TP / (iter_TP + iter_FP) else 0
iter_rec  <- if((iter_TP + iter_FN) > 0) iter_TP / (iter_TP + iter_FN) else 0
iter_ActualPos <- iter_TP + iter_FN
iter_ActualNeg <- iter_TN + iter_FP
iter_fnr <- if(iter_ActualPos > 0) iter_FN / iter_ActualPos else 0
iter_fpr <- if(iter_ActualNeg > 0) iter_FP / iter_ActualNeg else 0
dist_fnr[i] <- iter_fnr * 100
dist_fpr[i] <- iter_fpr * 100
# F1
iter_f1 <- if((iter_prec + iter_rec) > 0) {
(2 * iter_prec * iter_rec) / (iter_prec + iter_rec)
} else { 0 }
# F5
denom_beta <- (beta^2 * iter_prec) + iter_rec
iter_fbeta <- if(denom_beta > 0) {
((1 + beta^2) * (iter_prec * iter_rec)) / denom_beta
} else { 0 }
dist_f1[i]   <- iter_f1
dist_f5[i]   <- iter_fbeta
}
count_Above_AET <- total_TP + total_FN
count_Below_AET  <- total_TN + total_FP
FN_Rate_final <- total_FN / count_Above_AET
FP_Rate_final <- total_FP / count_Below_AET
recall <- total_TP / count_Above_AET
precision <- total_TP / (total_TP + total_FP)
F1 <- (2 * precision * recall / (precision + recall))
beta <- 5
f_beta <- (1 + beta^2) * (precision * recall) / ((beta^2 * precision) + recall)
SD_FN <- sqrt(FN_Rate_final * (1 - FN_Rate_final) / count_Above_AET)
SD_FP <- sqrt(FP_Rate_final * (1 - FP_Rate_final) / count_Below_AET)
summary_table <- rbind(summary_table, data.frame(
Method = "RRF<1",
FN_Rate = FN_Rate_final,
FP_Rate = FP_Rate_final,
FN_SD = SD_FN,
FP_SD = SD_FP,
precision = precision,
recall = recall,
F1 = F1,
f_beta = f_beta
))
metrics_df <- data.frame(
Method = "RRF<1",
F1 = dist_f1,
F5 = dist_f5,
Percent_FN = dist_fnr,
Percent_FP = dist_fpr
)
all_distributions <- rbind(all_distributions, metrics_df)
UF
summary_table
set.seed(123)
N_sim <- 10000
N_extractables <- 80
total_FN <- 0
total_FP <- 0
total_TP <- 0
total_TN <- 0
RRF_GCMS_superior0 <- gcms_clap_clean$"5 µg/mL"
RRF_GCMS_superior0 <- RRF_GCMS_superior0[RRF_GCMS_superior0 > 0]
conservative_RRF_estimate <- quantile(gcms_clap_clean$"5 µg/mL", 0.10)
for (i in 1:N_sim) {
## 1) Concentration around the AET
base_conc_sim <- runif(N_extractables, min = 0.5 * AET, max = 2 * AET)
## A) Sampling from the GC/MS dataset (5µg/mL)
simulated_RRF <- sample(gcms_clap_clean$"5 µg/mL", size = N_extractables, replace = FALSE)
## V
exp_conc <- base_conc_sim * simulated_RRF   # experimental concentration : True concentration with the actual RRF
corrected_conc <- exp_conc / conservative_RRF_estimate ## need to find rationale
is_above_threshold <- base_conc_sim > AET
reported_above_threshold <- corrected_conc > AET
## Count per iteration
iter_TP <- sum(is_above_threshold & reported_above_threshold, na.rm = TRUE)
iter_FP <- sum(!is_above_threshold & reported_above_threshold, na.rm = TRUE)
iter_FN <- sum(is_above_threshold & !reported_above_threshold, na.rm = TRUE)
iter_TN <- sum(!is_above_threshold & !reported_above_threshold, na.rm = TRUE)
total_TP <- total_TP + iter_TP
total_FP <- total_FP + iter_FP
total_FN <- total_FN + iter_FN
total_TN <- total_TN + iter_TN
# metrics per iterations
iter_prec <- if((iter_TP + iter_FP) > 0) iter_TP / (iter_TP + iter_FP) else 0
iter_rec  <- if((iter_TP + iter_FN) > 0) iter_TP / (iter_TP + iter_FN) else 0
iter_ActualPos <- iter_TP + iter_FN
iter_ActualNeg <- iter_TN + iter_FP
iter_fnr <- if(iter_ActualPos > 0) iter_FN / iter_ActualPos else 0
iter_fpr <- if(iter_ActualNeg > 0) iter_FP / iter_ActualNeg else 0
dist_fnr[i] <- iter_fnr * 100
dist_fpr[i] <- iter_fpr * 100
# F1
iter_f1 <- if((iter_prec + iter_rec) > 0) {
(2 * iter_prec * iter_rec) / (iter_prec + iter_rec)
} else { 0 }
# F5
denom_beta <- (beta^2 * iter_prec) + iter_rec
iter_fbeta <- if(denom_beta > 0) {
((1 + beta^2) * (iter_prec * iter_rec)) / denom_beta
} else { 0 }
dist_f1[i]   <- iter_f1
dist_f5[i]   <- iter_fbeta
}
count_Above_AET <- total_TP + total_FN
count_Below_AET  <- total_TN + total_FP
FN_Rate_final <- total_FN / count_Above_AET
FP_Rate_final <- total_FP / count_Below_AET
recall <- total_TP / count_Above_AET
precision <- total_TP / (total_TP + total_FP)
F1 <- (2 * precision * recall / (precision + recall))
beta <- 5
f_beta <- (1 + beta^2) * (precision * recall) / ((beta^2 * precision) + recall)
SD_FN <- sqrt(FN_Rate_final * (1 - FN_Rate_final) / count_Above_AET)
SD_FP <- sqrt(FP_Rate_final * (1 - FP_Rate_final) / count_Below_AET)
summary_table <- rbind(summary_table, data.frame(
Method = "Percentile 10th",
FN_Rate = FN_Rate_final,
FP_Rate = FP_Rate_final,
FN_SD = SD_FN,
FP_SD = SD_FP,
precision = precision,
recall = recall,
F1 = F1,
f_beta = f_beta
))
metrics_df <- data.frame(
Method = "Percentile 10th",
F1 = dist_f1,
F5 = dist_f5,
Percent_FN = dist_fnr,
Percent_FP = dist_fpr
)
all_distributions <- rbind(all_distributions, metrics_df)
set.seed(123)
N_sim <- 10000
N_extractables <- 80
total_FN <- 0
total_FP <- 0
total_TP <- 0
total_TN <- 0
RRF_GCMS_superior0 <- gcms_clap_clean$"5 µg/mL"
RRF_GCMS_superior0 <- RRF_GCMS_superior0[RRF_GCMS_superior0 > 0]
conservative_RRF_estimate <- quantile(gcms_clap_clean$"5 µg/mL", 0.20)
for (i in 1:N_sim) {
## 1) Concentration around the AET
base_conc_sim <- runif(N_extractables, min = 0.5 * AET, max = 2 * AET)
## A) Non-Parametric Bootstrap of the GC/MS dataset (5µg/mL)
simulated_RRF <- sample(gcms_clap_clean$"5 µg/mL", size = N_extractables, replace = FALSE)
## V
exp_conc <- base_conc_sim * simulated_RRF   # experimental concentration : True concentration with the actual RRF
corrected_conc <- exp_conc / conservative_RRF_estimate ## need to find rationale
is_above_threshold <- base_conc_sim > AET
reported_above_threshold <- corrected_conc > AET
## Count per iteration
iter_TP <- sum(is_above_threshold & reported_above_threshold, na.rm = TRUE)
iter_FP <- sum(!is_above_threshold & reported_above_threshold, na.rm = TRUE)
iter_FN <- sum(is_above_threshold & !reported_above_threshold, na.rm = TRUE)
iter_TN <- sum(!is_above_threshold & !reported_above_threshold, na.rm = TRUE)
total_TP <- total_TP + iter_TP
total_FP <- total_FP + iter_FP
total_FN <- total_FN + iter_FN
total_TN <- total_TN + iter_TN
# metrics per iterations
iter_prec <- if((iter_TP + iter_FP) > 0) iter_TP / (iter_TP + iter_FP) else 0
iter_rec  <- if((iter_TP + iter_FN) > 0) iter_TP / (iter_TP + iter_FN) else 0
iter_ActualPos <- iter_TP + iter_FN
iter_ActualNeg <- iter_TN + iter_FP
iter_fnr <- if(iter_ActualPos > 0) iter_FN / iter_ActualPos else 0
iter_fpr <- if(iter_ActualNeg > 0) iter_FP / iter_ActualNeg else 0
dist_fnr[i] <- iter_fnr * 100
dist_fpr[i] <- iter_fpr * 100
# F1
iter_f1 <- if((iter_prec + iter_rec) > 0) {
(2 * iter_prec * iter_rec) / (iter_prec + iter_rec)
} else { 0 }
# F5
denom_beta <- (beta^2 * iter_prec) + iter_rec
iter_fbeta <- if(denom_beta > 0) {
((1 + beta^2) * (iter_prec * iter_rec)) / denom_beta
} else { 0 }
dist_f1[i]   <- iter_f1
dist_f5[i]   <- iter_fbeta
}
count_Above_AET <- total_TP + total_FN
count_Below_AET  <- total_TN + total_FP
FN_Rate_final <- total_FN / count_Above_AET
FP_Rate_final <- total_FP / count_Below_AET
recall <- total_TP / count_Above_AET
precision <- total_TP / (total_TP + total_FP)
F1 <- (2 * precision * recall / (precision + recall))
beta <- 5
f_beta <- (1 + beta^2) * (precision * recall) / ((beta^2 * precision) + recall)
SD_FN <- sqrt(FN_Rate_final * (1 - FN_Rate_final) / count_Above_AET)
SD_FP <- sqrt(FP_Rate_final * (1 - FP_Rate_final) / count_Below_AET)
summary_table <- rbind(summary_table, data.frame(
Method = "Percentile 20th",
FN_Rate = FN_Rate_final,
FP_Rate = FP_Rate_final,
FN_SD = SD_FN,
FP_SD = SD_FP,
precision = precision,
recall = recall,
F1 = F1,
f_beta = f_beta
))
metrics_df <- data.frame(
Method = "Percentile 20th",
F1 = dist_f1,
F5 = dist_f5,
Percent_FN = dist_fnr,
Percent_FP = dist_fpr
)
all_distributions <- rbind(all_distributions, metrics_df)
summary_table
print(summary_table)
reticulate::repl_python()
gc_ms <- read_csv("final_model_data.csv") %>%
drop_na(BP, `Refractive Index`, TPSA, NHOHCount, NumHDonors, NumRotatableBonds, NOCount)
set.seed(123)
N_sim <- 10000
N_extractables <- 80
total_FN <- 0
total_FP <- 0
total_TP <- 0
total_TN <- 0
total_points <- N_sim * N_extractables
for (i in 1:N_sim) {
sim_data <- gc_ms %>%
sample_n(N_extractables, replace = TRUE)
## 1) Concentration around the AET
base_conc_sim <- runif(N_extractables, min = 0.5 * AET, max = 2 * AET)
## VI) RRF generated via the machine learning
simulated_RRF <- py$predict_rrf_raw(sim_data)
## no correction
corrected_conc <- base_conc_sim * simulated_RRF
is_above_threshold <- base_conc_sim > AET
reported_above_threshold <- corrected_conc > AET
## Count per iteration
iter_TP <- sum(is_above_threshold & reported_above_threshold, na.rm = TRUE)
iter_FP <- sum(!is_above_threshold & reported_above_threshold, na.rm = TRUE)
iter_FN <- sum(is_above_threshold & !reported_above_threshold, na.rm = TRUE)
iter_TN <- sum(!is_above_threshold & !reported_above_threshold, na.rm = TRUE)
total_TP <- total_TP + iter_TP
total_FP <- total_FP + iter_FP
total_FN <- total_FN + iter_FN
total_TN <- total_TN + iter_TN
# metrics per iterations
iter_prec <- if((iter_TP + iter_FP) > 0) iter_TP / (iter_TP + iter_FP) else 0
iter_rec  <- if((iter_TP + iter_FN) > 0) iter_TP / (iter_TP + iter_FN) else 0
iter_ActualPos <- iter_TP + iter_FN
iter_ActualNeg <- iter_TN + iter_FP
iter_fnr <- if(iter_ActualPos > 0) iter_FN / iter_ActualPos else 0
iter_fpr <- if(iter_ActualNeg > 0) iter_FP / iter_ActualNeg else 0
dist_fnr[i] <- iter_fnr * 100
dist_fpr[i] <- iter_fpr * 100
# F1
iter_f1 <- if((iter_prec + iter_rec) > 0) {
(2 * iter_prec * iter_rec) / (iter_prec + iter_rec)
} else { 0 }
# F5
denom_beta <- (beta^2 * iter_prec) + iter_rec
iter_fbeta <- if(denom_beta > 0) {
((1 + beta^2) * (iter_prec * iter_rec)) / denom_beta
} else { 0 }
dist_f1[i]   <- iter_f1
dist_f5[i]   <- iter_fbeta
}
count_Above_AET <- total_TP + total_FN
count_Below_AET  <- total_TN + total_FP
FN_Rate_final <- total_FN / count_Above_AET
FP_Rate_final <- total_FP / count_Below_AET
recall <- total_TP / count_Above_AET
precision <- total_TP / (total_TP + total_FP)
F1 <- (2 * precision * recall / (precision + recall))
beta <- 5
f_beta <- (1 + beta^2) * (precision * recall) / ((beta^2 * precision) + recall)
SD_FN <- sqrt(FN_Rate_final * (1 - FN_Rate_final) / count_Above_AET)
SD_FP <- sqrt(FP_Rate_final * (1 - FP_Rate_final) / count_Below_AET)
summary_table <- rbind(summary_table, data.frame(
Method = "Machine Learning",
FN_Rate = FN_Rate_final,
FP_Rate = FP_Rate_final,
FN_SD = SD_FN,
FP_SD = SD_FP,
precision = precision,
recall = recall,
F1 = F1,
f_beta = f_beta
))
metrics_df <- data.frame(
Method = "Machine Learning",
F1 = dist_f1,
F5 = dist_f5,
Percent_FN = dist_fnr,
Percent_FP = dist_fpr
)
all_distributions <- rbind(all_distributions, metrics_df)
summary_table
plot_data <- summary_table %>%
pivot_longer(cols = c(FN_Rate, FP_Rate), names_to = "Type", values_to = "Rate") %>%
mutate(
SD = ifelse(Type == "FN_Rate", round(FN_SD*100, 2), round(FP_SD*100, 2)),
Type = ifelse(Type == "FN_Rate", "False Negative", "False Positive")
)
method_levels <- c(
"No Correction",
"UF (2)",
"UF (4)",
"UF (5)",
"UF (10)",
"UF (RSD)",
"Mean/Percentile (16th)",
"RRFlow",
"RRF<1",
"Percentile 10th",
"Percentile 20th",
"Machine Learning")
plot_data$Method <- factor(plot_data$Method, levels = method_levels)
ggplot(plot_data, aes(x = Method, y = Rate*100, fill = Type)) +
geom_bar(stat = "identity", position = position_dodge(width = 0.9), alpha = 0.8) +
geom_errorbar(aes(ymin = pmax(0, Rate*100 - 1.96*SD), ymax = Rate*100 + 1.96*SD),
position = position_dodge(width = 0.9), width = 0.2) +
labs(
title = paste0("Comparison of GC-MS Correction Methods (5 µg/mL)", " AET=", AET, "µg/mL"),
subtitle = "Conc. Uniform distribution (around AET), RRF sampled from CLAP list data",
y = "Rate (%)",
x = "Method") +
geom_text(aes(label = sprintf("%.1f%%", Rate*100)), position = position_dodge(width = 0.9), hjust = -0.5, size = 3, vjust = 0.1) +
scale_fill_manual(values = c("False Negative" = "red", "False Positive" = "grey")) +
scale_y_continuous(limits = c(0, 100)) +
theme_minimal() +
coord_flip()
all_distributions$Method <- factor(all_distributions$Method, levels = method_levels)
ggplot(all_distributions, aes(x = Method, y = F5)) +
geom_violin(fill = "orange", alpha = 0.6) +
geom_boxplot(width = 0.1, color = "black", alpha = 0.5) +
labs(
title = paste0("Distribution of F5 scores | GC-MS Correction Methods (5 µg/mL)", " AET=", AET, "µg/mL"),
subtitle = "Conc. Uniform distribution (around AET), RRF sampled from CLAP list data") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
plot_data_FN_FP <- pivot_longer(all_distributions,
cols = c("F5", "Percent_FN", "Percent_FP"),
names_to = "Metric",
values_to = "Value")
plot_data_FN_FP$Method <- factor(plot_data_FN_FP$Method, levels = method_levels)
cluster_centers <- all_distributions %>%
group_by(Method) %>%
summarize(
center_FP = mean(Percent_FP, na.rm = TRUE),
center_FN = mean(Percent_FN, na.rm = TRUE)
)
ggplot(all_distributions, aes(x = Percent_FP, y = Percent_FN, color = Method)) +
# Plot the individual simulation dots
geom_point(alpha = 0.05, size = 1) +
# Draw the 95% confidence ellipses
stat_ellipse(linewidth = 1, linetype = 1, type = "norm", level = 0.95) +
geom_label_repel(
data = cluster_centers,
aes(x = center_FP, y = center_FN, label = Method),
size = 4,
fontface = "bold",
alpha = 0.9,
show.legend = FALSE,
box.padding = 0.5,         # Adds "repel force" around the label itself
point.padding = 0.5,       # Keeps the label from sitting directly on the exact center coordinate
segment.color = "black",   # Makes the pointer line black so it stands out
segment.size = 0.8         # Makes the pointer line a bit thicker
) +
# Clean up the labels and aesthetics
labs(
title = "Trade-off: False Positives vs. False Negatives",
subtitle = paste0("10,000 Simulations per Method | AET = ", AET, " µg/mL"),
x = "False Positive Rate (%)",
y = "False Negative Rate (%)",
color = "Correction Method"
) +
# Clean theme
theme_minimal() +
theme(
# Optional: If you want to remove the legend entirely now that you have labels,
# change "bottom" to "none"!
legend.position = "none",
panel.grid.minor = element_blank(),
plot.title = element_text(face = "bold")
)
Sys.setenv(RETICULATE_PYTHON = "C:/Users/misak/anaconda3/python.exe")
#install.packages("tabulapdf")
# Load required packages
library(tidyverse)
library(dplyr)
library(purrr)
library(lubridate)
library(ggplot2)
library(ggrepel)
library(here)
library(parallel)
library(pdftools)
library(stringr)
library(readxl)
library(reticulate)
library(MASS)
#py_install(c("pandas", "joblib", "scikit-learn"))
cluster_centers <- all_distributions %>%
group_by(Method) %>%
summarize(
center_FP = mean(Percent_FP, na.rm = TRUE),
center_FN = mean(Percent_FN, na.rm = TRUE)
)
ggplot(all_distributions, aes(x = Percent_FP, y = Percent_FN, color = Method)) +
# Plot the individual simulation dots
geom_point(alpha = 0.05, size = 1) +
# Draw the 95% confidence ellipses
stat_ellipse(linewidth = 1, linetype = 1, type = "norm", level = 0.95) +
geom_label_repel(
data = cluster_centers,
aes(x = center_FP, y = center_FN, label = Method),
size = 4,
fontface = "bold",
alpha = 0.9,
show.legend = FALSE,
box.padding = 0.5,         # Adds "repel force" around the label itself
point.padding = 0.5,       # Keeps the label from sitting directly on the exact center coordinate
segment.color = "black",   # Makes the pointer line black so it stands out
segment.size = 0.8         # Makes the pointer line a bit thicker
) +
# Clean up the labels and aesthetics
labs(
title = "Trade-off: False Positives vs. False Negatives",
subtitle = paste0("10,000 Simulations per Method | AET = ", AET, " µg/mL"),
x = "False Positive Rate (%)",
y = "False Negative Rate (%)",
color = "Correction Method"
) +
# Clean theme
theme_minimal() +
theme(
# Optional: If you want to remove the legend entirely now that you have labels,
# change "bottom" to "none"!
legend.position = "none",
panel.grid.minor = element_blank(),
plot.title = element_text(face = "bold")
)
library(quarto)
# 1. Get a list of all .qmd files in the current directory
files <- list.files(pattern = "\\.qmd$", full.names = TRUE)
# 2. Loop through and render each one
for (file in files) {
message(paste("Rendering:", file))
tryCatch({
quarto_render(file)
message(paste("Successfully rendered:", file))
}, error = function(e) {
message(paste("Failed to render:", file))
message(e)
})
}
